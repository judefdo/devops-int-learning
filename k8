***** IMPORTANt
https://www.replex.io/blog/kubernetes-in-production-best-practices-for-cluster-autoscaler-hpa-and-vpa
https://aws.amazon.com/blogs/containers/amazon-eks-cluster-multi-zone-auto-scaling-groups/
https://opsani.com/blog/kubernetes-cluster-autoscaling-overview/
https://aws.amazon.com/blogs/compute/run-your-kubernetes-workloads-on-amazon-ec2-spot-instances-with-amazon-eks/
https://rancher.com/docs/rancher/v2.x/en/cluster-admin/cluster-autoscaler/amazon/


QoS - Quality of Service
        1- Guartee --> when memory limit and request are same
        2- Burstable --> when memory limit is more than the request 
        3- Besteffort --> if you don't specify any limit on the pod definition

Defaulf definition: 
       you can specify a yml with limitRange like
        apiVersion: v1
        kind: LimitRange
        metadata:
            name: mem-limit-range
        spec:
            limits:
            - default:
                  memory: 512Mi
            defaultRequest:
                  memory: 256Mi
            type: Container

Initial namespace
  - default
  - kube-system
  - kube-public


A Daemon set is a set of pods that runs only once on a host. 
They are used for host layer attributes like a network or for monitoring a network,
 which you may not need to run on a host more than once.

A Heapster is a performance monitoring and metrics collection system for data collected by the Kublet. 
This aggregator is natively supported and runs like any other pod within a Kubernetes cluster, 
which allows it to discover and query usage data from all nodes within the cluster.

The controller manager is a daemon that is used for embedding core control loops, garbage collection, and Namespace creation. 
It enables the running of multiple processes on the master node even though they are compiled to run as a single process.

The primary controller managers that can run on the master node are the 
endpoints controller, service accounts controller, namespace controller, node controller, token controller, and replication controller.

Kubernetes uses etcd as a distributed key-value store for all of its data, including metadata and configuration data, 
and allows nodes in Kubernetes clusters to read and write data. Although etcd was purposely built for CoreOS, 
it also works on a variety of operating systems (e.g., Linux, BSB, and OS X) because it is open-source. 
Etcd represents the state of a cluster at a specific moment in time and is a canonical hub for state management and 
cluster coordination of a Kubernetes cluster.


Kubernetes service without selector, will not create a endpoint. you need to create a end point manually. 

Kubernetes has 3 type of kube-proxy :
  user-space proxy mode:
      It uses proxy-port and uses kube-proxy the SessionAffinity for the service
      Lastly, the user-space proxy installs iptables rules which capture traffic to the Service’s clusterIP (which is virtual) and port. 
      The rules redirect that traffic to the proxy port which proxies the backend Pod. It uses round robin method

  iptable proxy mode:
      Service, it installs iptables rules, which capture traffic to the Service’s clusterIP and port, and 
      redirect that traffic to one of the Service’s backend sets. For each Endpoint object, it installs iptables rules which select a backend Pod.
      It uses linux kernel for processing , kube-proxy in iptables mode chooses a backend at random. It uses readyness probe to 

 IPVS mode: it uses call netlink interface , it uses kernel mode, IPVS mode has higher through put of network traffic


 Discovering services:
   through environement variables and DNS

 Headless Services:
     There is no Cluster IP created or kube-proxy doesn't handle these services, and there is no load balancing and proxying done 
     by platform.
   
An ExternalName Service is a special case of Service that does not have selectors and uses DNS names instead.
ExternalName: Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record


kube-proxy : ??


Kubernetes operators -- 


How to add entry to pod /etc/resolv.conf 
Using the pod definition script:
   apiVersion: v1
kind: Pod
metadata:
  namespace: default
  name: dns-example
spec:
  containers:
    - name: test
      image: nginx
  dnsPolicy: "None"
  dnsConfig:
    nameservers:
      - 1.2.3.4
    searches:
      - ns1.svc.cluster-domain.example
      - my.dns.search.suffix
    options:
      - name: ndots
        value: "2"
      - name: edns0

The above pod definition will create an entry in /etc/resolv.conf

nameserver 1.2.3.4
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0


A headless service is used to interface with service discovery mechanisms without being tied to a ClusterIP, therefore allowing you to directly reach pods without having to access them through a proxy. It is useful when neither load balancing nor a single Service IP is required. 



Jasonnet
